#####################LIBRARIES###################################
from datetime import datetime
import sys
import os
import json
from bisect import bisect
#####################GLOBAL VARIABLES#############################
# changes List.. this will be list in order to not be immutable
'''
  global variables declaration
'''
changesList = [] #list that keeps the changes done to the file
change_lines = 0 #keeps the number of lines afte the changes 
curr_tweet_id = 0 #current tweet id 
deletions = 0 # number of deletions made
deletion_numbers_list=[]
file_lines =0
######################FUNCTION PART#############################
# changes List.. this will be list in order to not be immutable

'''
  file_len

  Arguments:
    Arg1: (str)filename
  Returns:
    int: number of lines in given file
  Description: 
    Count the lines of given file

'''
def file_len(f): 
    for i, _ in enumerate(f): # _ goes to last expression. practically throws the last line read all the time to parse through the file
            pass
    return i + 1


'''
  createTweet

  #TODO: update curr_tweet_id to the last one --> done
  #TODO: deletion countdown ... less disk accesses --> 
  Description:
    Function that creates a new json line with the parameters text and created_at.
    The text field is given by the user while the create_at field is auto generated by
    datetime lib. 
    In the end it updates the current tweet id to the new one.
'''
def createTweet() -> None: #testing function # testing done
  tweet_text = input("Please share your thoughts:\t")
  # need the first dict to keep track of twitter_id in the changes list and update the 
  globals()['change_lines'] = change_lines +1
  # take the date from the lib
  date = datetime.now() 

  # append to the changes list. 
  # format the date while putting in dictionary
  changesList.append([change_lines, "create" ,{"text":tweet_text , "created_at": date.strftime("%d/%m/%Y %H:%M:%S")}])

  #update curr_tweet_id to the new one
  globals()['curr_tweet_id'] = change_lines
 

'''
  search_in_changelist


  #TODO: read in changesList correctly --> done

  Arguements:
    Arg1: int: lines --> the lines that have to be in the file with changes

  Returns:
    correct/wrong -> Str

  Description:

    The function drives through the changes list searching for the List that has as
    assigned lined to go the change_lines one. Then returns the text from the dictionary that 
    alligns with the same field found. 
'''
def search_in_changelist(lines:int) -> str:
  i=0
  for i in range(len(changesList)):
    if lines == changesList[i][0] and changesList[i][1] != 'delete':
      return str(changesList[i][2]['text'])
    elif lines == changesList[i][0] and changesList[i][1] == 'delete':
      return str(changesList[i][1])
  return None

'''
  search_for_update

  Arguments:
    Arg1: (int)line
  Returns:
    int: number in list that contains the info searched
  Description: 
    function that searches if the line that is searched is already been processed but not deleted. 
'''
def search_for_update(line:int) -> int: 
  i=0
  for i in range(len(changesList)):
    if line == changesList[i][0] and changesList[i][1] != "delete":
      return i
  return -1


'''
  deleteTweet

  Arguments:
    Arg1: (int) curr_tweet_id
  Returns:
    None
  Description:
    keeps a log of the deletion asked to be made so the deletions come right after update of the file
'''
def deleteTweet(curr_tweet_id:int)-> None:
  # check if the tweet is already
  check_alter = search_for_update(curr_tweet_id)
  if(check_alter != -1):
    #case the deletion is on something on the list
    changesList[check_alter] = [curr_tweet_id, "delete"]
  else:
    # in case it hasn't altered already
    changesList.append([curr_tweet_id, "delete"])
  
  # update the necessary variables to keep track 
  globals()['deletions'] = deletions +1
  globals()['change_lines'] = change_lines -1
  # update the list of deletions in order to keep track 
  deletion_numbers_list.append(curr_tweet_id) 


'''
  check_deletions

  Arguments:
    Arg1: (int) line
  Returns: 
    int -> position that the int would have been if there are deletions
  Description:
    The function returns the position of the deletion table that the line should be inserted. This helps
    to locate how many lines we must add to our search.
'''
def check_deletions(line: int)-> int:
  # sort the array
  deletion_numbers_list.sort()
  return int (bisect(deletion_numbers_list,line))


def read_n_to_last_line(filename, n = 1):
  try:
    filename.seek(-2, os.SEEK_END)    
    while num_newlines < n:
      filename.seek(-2, os.SEEK_CUR)
      if filename.read(1) == b'\n':
        num_newlines += 1
  except OSError:
    filename.seek(0)
    last_line = filename.readline().decode()
  return last_line



'''
  readSpecificTweet

  #TODO: read specific lines in the file --> 
  #TODO: read from changes list --> done
  #TODO: read from locality list --> 
  #TODO: update locality list --> 
  Arguements:
    Arg1: int: line  -> specific line that is searching
  
  Description:
    #TODO:
'''
def readSpecificTweet(line: int, filename) -> None:
  #first thing to do search if the current line number is in change list
  if( line > change_lines): #maybe try catch there
    print("No such many tweets")
  else:
    if deletions ==0:
      string = search_in_changelist(line)
      if string == None:
        search_line = file_lines - line +1 #find the corresponding line from the end
        read_n_to_last_line(filename, search_line)
      else:
        print("The text of the tweet with tweet id "+ str(line) +" is: \n" +string)
    else:
      new_line = line + check_deletions(line) 
      string = search_in_changelist(new_line)
      if string == None:
        search_line = file_lines - new_line +1 #find the corresponding line from the end
        read_n_to_last_line(filename, search_line)
      else:
        print("The text of the tweet with tweet id "+ str(line) +" is: \n" +string)
      globals['curr_tweet_id'] = line


'''
  updateTweet
  
  #TODO: double update search the list --> needs to be tested
'''
def updateTweet(line: int) -> None: 
  tweet_text = input("Please share your thoughts")
  date = datetime.now() 

  #check if exists already
  check_str = search_for_update(line)
  if check_str == -1:
  # append to the changes list. 
  # format the date while putting in dictionary
    changesList.append([line, "update",{"text":tweet_text , "created_at": date.strftime("%d/%m/%Y %H:%M:%S")}])
  else:      
      changesList[check_str] = [line, "update" ,{"text":tweet_text , "created_at": date.strftime("%d/%m/%Y %H:%M:%S")}]
  #update curr_tweet_id to the new one
  globals()['curr_tweet_id'] = line


'''
  readLastTweet

  #TODO: Case with no deletion and same values --> done
  #TODO: Case with deletion and same values -->
  #TODO: Case changes_lines > file_lines --> done
  #TODO: Case with change_lines < file_lines (NEEDS: deletion) --> 
  #TODO: Update curr_tweet_id --> done

  Usage: 
    The function checks first if the file_lines < change_lines. Case that is true, this means that we have updates not migrated.
    The function then checks the changesList array and finds the tweet with the biggest tweet_id and prints it. if the number is 
    the same, checks if there are any deletions. if not prints the last line of the file. else searches the tweet_id equal to file_lines
    and prints it. The fact that the user creates tweets that get appended only at the end of the file means that if change_lines > file_lines 
    only custom tweets will be found at last.
'''
def readLastTweet(JsonFile) -> None:
  if(file_lines == change_lines):
    # assume no deletion has been done for now
    try: 
        JsonFile.seek(-2, os.SEEK_END)
        while JsonFile.read(1) != b'\n':
            JsonFile.seek(-2, os.SEEK_CUR)
        text = (JsonFile.readline().decode()) # take the tweet with the last tweet_id as a string

        result = json.loads(text) #convert it to json dict
        print("The text of the tweet with tweet id "+ str(change_lines) +" is: \n" +result['text']) #can only concat str not int
    except OSError: #Case we cannot seek in the file ... mainly this will throw cause of wrong opening (not in binary)
        JsonFile.seek(0)
        print("Something went wrong")
  elif(file_lines < change_lines):
    text = search_in_changelist(change_lines) # python doest not print callbacks
    print("The text of the tweet with tweet id "+ str(change_lines) +" is: \n" + str(text))
  else:
    sys.exit("Possible corrupted file.\nAll changes have been reverted.\nProgram Exiting")
  #Update curr_tweet_id. change lines will always have the right amount of lines that should be in the file
  globals()['curr_tweet_id'] = change_lines


'''
  help
  
  Usage:
    Used in case of help/h given as an input or if the user's input is wrong
'''
def help(): #testing function # testing done
  print()
  print("Options:")
  print("c : Create Tweet")
  print("r<number> : Read the tweet with tweet ID <number>")
  print("u<number> : Update the tweet at with tweet ID <number>")
  print("d : delete current tweet")
  print("$ : Read the last tweet in files")
  print("- : Read one tweet up from the current tweet ")
  print("+ : Read one tweet down from current tweet")
  print("= : Print current tweet ID")
  print("q : Quit without save")
  print("w : (Over)write file to disk")
  print("x : Exit and save")


def read_one_down(filename)->None:
  if curr_tweet_id+1 < change_lines:
    deletion_position = check_deletions()
    if deletion_position == 0: 
      string = search_in_changelist(curr_tweet_id+1)
      if string== None:
        search_line = file_lines - (curr_tweet_id+1) +1 #find the corresponding line from the end
        read_n_to_last_line(filename, search_line)
      else:
        print("The text of the tweet with tweet id "+ str(curr_tweet_id+1) +" is: \n" +string)
    else:
      string = search_in_changelist(curr_tweet_id+1+deletion_position)
      if string== None:
        search_line = file_lines - (curr_tweet_id+1) + 1 #find the corresponding line from the end
        read_n_to_last_line(filename, search_line)
      else:
        print("The text of the tweet with tweet id "+ str(curr_tweet_id+1) +" is: \n" +string)
    globals['curr_tweet_id'] = curr_tweet_id+1
  else: # we are at the end of the file
    print("There are no more lines")

def read_one_up(filename)->None:
  if curr_tweet_id-1 < 0:
    print("You have reached the top of the file. No more tweets to read")
  else:
    deletion_position = check_deletions()
    if deletion_position == 0: 
      string = search_in_changelist(curr_tweet_id-1)
      if string== None:
        search_line = file_lines - (curr_tweet_id-1) +1 #find the corresponding line from the end
        read_n_to_last_line(filename, search_line)
      else:
        print("The text of the tweet with tweet id "+ str(curr_tweet_id-1) +" is: \n" +string)
    else:
      string = search_in_changelist(curr_tweet_id-1+deletion_position)
      if string== None:
        search_line = file_lines - (curr_tweet_id-1) + 1 #find the corresponding line from the end
        read_n_to_last_line(filename, search_line)
      else:
        print("The text of the tweet with tweet id "+ str(curr_tweet_id+1) +" is: \n" +string)
    globals['curr_tweet_id'] = curr_tweet_id-1


def updateFile(filename)-> None:
  readFile = open("testfile.json", "r")
  writeFile = open("testfile1.json", "w")
  cur_line=0
  lines_checked =0
  while cur_line < change_lines:
    if cur_line == changesList[lines_checked][0]:
      if changesList[lines_checked][1] != 'deleted':
        writeFile.write(changesList[lines_checked][2] + "\n")
      if cur_line < file_lines:
        readFile.readline() # so the line checker is correct
      lines_checked = lines_checked +1 # update the lines checked already
    else:
      readLine = readFile.readline()
      writeFile.write(readLine)

'''
  checkAndExecute

  #TODO: Check for correct. --> done
  #TODO: Check max args based on file. --> abort 
  #TODO: Recomendation about the error based on command. --> done
  
  Arguments:
    Arg1 : (str) option
  Returns:
    bool : True/False 
  
  Usage: 
    Checks if the given input is valid. 

    If the input is valid the function returns True meaning the input is
    justifiable for processing. 

    If the input is not valid the function returns False meaning that input has 
    to be given again
'''
def checkAndExecute(option:str) -> None: 
  if len(option) == 1: 
    if option == 'C' or option == 'c': # testing scenario # testing done
      createTweet()
    elif option == 'd' or option == 'D': 
      print(option + " d/D")
    elif option == '$':
      readLastTweet(JsonFile)
    elif option == '-':
      print(option + " -")
    elif option == '+': 
      print(option + " +")
    elif option == '=': # testing scenario # testing done
      print(curr_tweet_id)
    elif option == 'q' or option == 'Q': # testing scenario # testing done
      sys.exit("\nExiting program")
    elif option == 'w' or option == 'W':
      print(option + " w/W")
    elif option == 'x' or option == 'X':
      sys.exit("\nExiting program")
    elif option =='h':  #testing scenario # testing done
      help()
    else: # testing scenario #testing done
      print("\nError: Wrong given arguement")
      help()
  elif len(option)> 1: 
    if option[0] == 'r':
      print(option)
      optionT = option.split('r', 1)
      try:
        readSpecificTweet(int(optionT[1])) 
      except: # testing scenario # testing done
          print("\nThe given arguement does not translate to integer")
          help()
    elif option[0] == 'u': 
      optionT = option.split('u')
      try:
        updateTweet(int(optionT[1]))
      except: # testing scenario # testing done
          print("\nThe given arguement does not translate to integer")
          help()
    elif option == "help": # testing scenario # testing done
      help()
    else:  # testing scenario # testing done
      print("\nError: Wrong given arguement")
      help()



######################EXECUTION PART######################
print("Twitter Editor and Viewer")

### File opening.
try:
    #open as binary helps with SEEK etc.
    JsonFile = open("testfile.json", "rb")
    print("Please wait while the file is opening")
    globals['file_lines'] = file_len(JsonFile)
    change_lines = file_lines
    print(file_lines)
except OSError: 
    sys.exit("File opening failed. The program will now terminate")

# The following code runs as a do while
choice = input("Give your choice:\t")
#checkAndExecute(choice)

while True:
  checkAndExecute(choice)
  choice = input("Give your choice:\t")

